name: "HashiCorp Vault Env Loader"
description: "Securely fetch secrets from HashiCorp Vault and export them as environment variables or a .env file"
author: "noor-mbarek"
branding:
  color: purple
  icon: lock

inputs:
  vault_addr:
    description: "Vault server address"
    required: true
  vault_role_id:
    description: "Vault AppRole Role ID"
    required: true
  vault_secret_id:
    description: "Vault AppRole Secret ID"
    required: true
  vault_path:
    description: "Vault KV path (e.g. secret/dev)"
    required: true
  import_type:
    description: "How to import secrets (env_file | exported_env_vars)"
    required: false
    default: "exported_env_vars"
  export_path:
    description: "Path to write .env file (only used if import_type=env_file)"
    required: false
    default: "./.env"

runs:
  using: "composite"
  steps:
    - name: Install Vault CLI
      shell: bash
      run: |
        set -e
        VAULT_VERSION="1.18.2"
        echo "â¬‡ï¸ Installing Vault CLI v${VAULT_VERSION}..."
        curl -fsSL "https://releases.hashicorp.com/vault/${VAULT_VERSION}/vault_${VAULT_VERSION}_linux_amd64.zip" -o vault.zip
        unzip vault.zip >/dev/null
        sudo mv vault /usr/local/bin/
        vault --version
        sudo apt-get update -y && sudo apt-get install -y jq curl
        echo "âœ… Vault and jq installed."

    - name: Fetch Secrets from Vault (universal KV detection)
      shell: bash
      env:
        VAULT_ADDR: ${{ inputs.vault_addr }}
        VAULT_ROLE_ID: ${{ inputs.vault_role_id }}
        VAULT_SECRET_ID: ${{ inputs.vault_secret_id }}
        VAULT_PATH: ${{ inputs.vault_path }}
        IMPORT_TYPE: ${{ inputs.import_type }}
        EXPORT_PATH: ${{ inputs.export_path }}
      run: |
        set -euo pipefail

        echo "ðŸ” Authenticating with Vault..."
        VAULT_TOKEN=$(vault write -field=token auth/approle/login \
          role_id="$VAULT_ROLE_ID" \
          secret_id="$VAULT_SECRET_ID")
        export VAULT_TOKEN

        echo "ðŸ“¦ Resolving KV engine for: $VAULT_PATH"
        MOUNT=$(echo "$VAULT_PATH" | cut -d'/' -f1)
        RELATIVE_PATH=$(echo "$VAULT_PATH" | cut -d'/' -f2-)

        # Fetch mount metadata (robust parsing)
        RAW_MOUNTS=$(curl -s -H "X-Vault-Token: $VAULT_TOKEN" "$VAULT_ADDR/v1/sys/mounts" | jq -r '.data')
        VERSION=$(echo "$RAW_MOUNTS" | jq -r --arg M "${MOUNT}/" '
          to_entries[]
          | select(.key|startswith($M))
          | .value.options.version // "1"
          ' | head -n 1)

        if [[ -z "$VERSION" || "$VERSION" == "null" ]]; then
          VERSION="1"
        fi

        echo "ðŸ”Ž Mount '$MOUNT' detected as KV v$VERSION"

        if [[ "$VERSION" == "2" ]]; then
          echo "âž¡ï¸ Using KV v2 path: $VAULT_PATH"
          DATA=$(vault kv get -format=json "$VAULT_PATH" | jq -r '.data.data')
        else
          echo "âž¡ï¸ Using KV v1 path: $VAULT_PATH"
          DATA=$(vault kv get -format=json "$VAULT_PATH" | jq -r '.data')
        fi

        if [[ -z "$DATA" || "$DATA" == "null" ]]; then
          echo "âŒ No secrets found at path: $VAULT_PATH"
          exit 1
        fi

        if [[ "$IMPORT_TYPE" == "exported_env_vars" ]]; then
          echo "ðŸ“¤ Exporting secrets as environment variables..."
          echo "$DATA" | jq -r 'to_entries | .[] | "export \(.key)=\(.value)"' >> "$GITHUB_ENV"
          echo "âœ… Environment variables exported."
        else
          echo "ðŸ“ Writing secrets to: $EXPORT_PATH"
          mkdir -p "$(dirname "$EXPORT_PATH")"
          echo "$DATA" | jq -r 'to_entries | .[] | "\(.key)=\(.value)"' > "$EXPORT_PATH"
          echo "âœ… .env file created successfully."
        fi

        unset VAULT_TOKEN
